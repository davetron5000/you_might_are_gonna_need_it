You might “Are Gonna Need It” - Avoiding the MonoRail
!TITLE
You might “Are Gonna Need It”
Avoiding the MonoRail
@davetron5000

!SECTION
Me

!NORMAL
@davetron5000

!BULLETS
Lead Engineer @ Stitch Fix
* One horrible Django App
* Special-purpose Rails Apps
* Gems & Services

!BULLETS
Former Engineer @ LivingSocial
* One giant monorail
* Array of payment-related services

!IMAGE
images/book.png

!SECTION
What's a MonoRail?
<img src="images/monorail.jpg">

!BULLETS
A MonoRail
* Monolithic
* Rails app
* Too big, too hard to change over time

!NORMAL
It <strong>will</strong> happen

!BULLETS
Fixing a MonoRail
* Create new applications
* Split applications
* Extract Services

!NORMAL
Can we prepare ourselves?

!QUOTE
<a href="http://c2.com/cgi/wiki?YouArentGonnaNeedIt">YAGNI</a>
<blockquote>Always implement things when you actually need them, never when you just foresee that you need them.</blockquote>

!BULLETS
YAGNI is <strong>not</strong>:
* Pooping out code
* A reason for technical debt
* An excuse for not thinking

!NORMAL
Can we prepare ourselves...
...without wasting time/effort now?

!BULLETS
Avoiding the MonoRail in 3 Steps
* Make deployment and provisioning easy
* Use your database
* Better-factored code

!NUMSECTION
1
Make Deployment & Provisioning Easy

!QUOTE
Creating a MonoRail in one step
<blockquote>Let's just put that new feature it in the app because it's too much of a pain to make a new app</blockquote>

!NORMAL
Frictionless Provisioning

!NORMAL
<tt>rails new</tt> for <strong>your</strong> team

!NORMAL
Rails App Generator

!NORMAL
Provision and Deploy in one step

!NORMAL
Minimum Deployable Application

!BULLETS
Remove gatekeepers
* QA ⇒ Better Tests
* Physical Deployment ⇒ Learn you some scripting

!IMAGE
images/book.png

!NORMAL
Stand-up new services whenever they are needed

!NORMAL
Push changes without heavy coordination

!NORMAL
Discussions are about what apps to make,
not how to make them.

!NORMAL
If all else fails…
…use Rails engines to keep yourself honest

!NUMSECTION
2
Use Your Database

!IMAGE
images/god_emperor.jpg

!BULLETS
The Golden Path
* No other apps touch the database
* Validations ensure data integrity

!CODE: language=ruby
def up
  create_table :orders do |t|
    t.belongs_to :customer
    t.string     :name
    t.integer    :order_type
    t.date       :shipped_on
    t.timestamps
  end
end

!CODE: language=ruby
create_table :orders do |t|
  t.belongs_to :customer,   null: false
  t.string     :name,       null: true
  t.integer    :order_type, null: false
  t.date       :shipped_on, null: true
  t.timestamps
end
execute "ALTER table things 
         ADD FOREIGN KEY 
         (customer_id) REFERENCES customer(id);"

!CODE: language=ruby callout=2,3,4,5
create_table :orders do |t|
  t.belongs_to :customer,   null: false
  t.string     :name,       null: true
  t.integer    :order_type, null: false
  t.date       :shipped_on, null: true
  t.timestamps
end
execute "ALTER table things 
         ADD FOREIGN KEY 
         (customer_id) REFERENCES customer(id);"

!CODE: language=ruby callout=8,9,10
create_table :orders do |t|
  t.belongs_to :customer,   null: false
  t.string     :name,       null: true
  t.integer    :order_type, null: false
  t.date       :shipped_on, null: true
  t.timestamps
end
execute "ALTER table things 
         ADD FOREIGN KEY 
         (customer_id) REFERENCES customer(id);"

!BULLETS
Use the Database
* Explicit nullability
* Foreign keys
* Check constraints (if DB supports)

!NUMSECTION
3
Better-Factored Code

!NORMAL
Not demonstrating Rails' features

!NORMAL
Deliver value…
…through software…
…using Rails

!BULLETS
Two steps to better-factored code
* Not everything is an ActiveRecord object
* Not all code belongs on a model

!NUMSECTION
3.1
Not everything is an ActiveRecord object

!CODE: language=erb
&lt;h1&gt;Purchase &lt;%= @purchase.id %&gt;&lt;/h1&gt;
&lt;h2&gt;for &lt;%= @purchase.customer.name %&gt;&lt;/h2&gt;
&lt;dl&gt;
  &lt;dt&gt;Item&lt;/dt&gt;
  &lt;dd&gt;&lt;%= @purchase.item.description %&gt;&lt;/dd&gt;
  &lt;dt&gt;Price&lt;/dt&gt;
  &lt;dd&gt;&lt;%= @purchase.price %&gt;&lt;/dd&gt;
&lt;/dl&gt;

!BULLETS
Bad
* Changes to purchase, customer, and item all cause this to change
* If data comes from API call, this gets messy

!CODE: language=ruby
class PurchasePresenter
  def initialize(purchase)
    @purchase = purchase
    @customer = purchase.customer
    @item     = purchase.item
  end

  def customer_name;    @customer.name;    end
  def purchase_price;   @purchase.price;   end
  def purchase_id;      @purchase.id;      end
  def item_description; @item.description; end
end

!NORMAL
Just kicking the can down the road

!NORMAL
Decorators, Delgators, Exhibits?

!NORMAL
STILL just kicking the can…
…but hampering readability

!CODE: language=ruby
class PurchaseRecord
  extend  ActiveModel::Naming
  include ActiveModel::Conversion

  def persisted?; true; end

  attr_reader :customer_name,
              :purchase_price,
              :purchase_id,
              :item_description

  def initialize(attribtues={})
    @customer_name    = attributes[:customer_name]
    @purchase_price   = attributes[:purchase_price]
    @purchase_id      = attributes[:purchase_id]
    @item_description = attributes[:item_description]
  end
end

!CODE: language=ruby
class PurchaseRecord
  def self.from_purchase(purchase)
    self.new(customer_name: purchase.customer.name,
            purchase_price: purchase.price,
               purchase_id: purchase.id,
          item_description: purchase.item.description)
  end
end

!BULLETS
Better
* View treats as dumb struct
* Other code treats as dumb struct
* Construction localized to one method
* Can be replaced by <code>OpenStruct</code>

!BULLETS
This is also just better code
* Named for what it is, not what it does
* Rails treats it as a model for form helpers
* Same effort to implement
* Clearer tests

!NUMSECTION
3.2
Not All Code Belongs to a Model

!BULLETS
How Stitch Fix processes returns
* Shipment is marked as received
* Check if user has paid for kept items
* Check if unpaid items were returned
* Record status of each item - sold, recieved, damanged
* Charge customer if they haven't paid
* Email customer service any outliers

!BULLETS
What model does this go with?
* <code>Return</code>? Why would it know about charging customers?
* <code>Shipment</code>? Why would it know emailing customer service?
* A series of observers, hooks, callbacks and delegators?

!NORMAL
KISS

!NORMAL
Keep It Simple
(Stupid)

!NORMAL
Consider Service Objects

!CODE: language=ruby
class ReturnProcessor
  def self.process!(the_return,logged_in_user)
    # All that crazy logic
  end
end

!BULLETS
Better
* Single-purpose class, based on business logic
* One location where code lives
* One location for the tests
* Can be swapped out with few changes to code

!NORMAL
This isn't YAGNI,
it's a design decision.

!NORMAL
Remember, you aren't demonstrating features of Rails (or Ruby)

!SECTION
When the MonoRail approaches

!BULLETS
When the MonoRail approaches
* Provising + Deploy
* Use the database
* Well-factored code

!BULLETS
New/Split applications
* Provision + Deploy in one step
* Share business logic via gems
* Shared data access protected by constraints

!BULLETS
Service Extraction
* Provision + Deploy in one step
* Move service layer to new app
* Replace service layer with API calls

!SECTION
The End
@davetron5000
http://www.naildrivin5.com
